/*
**
**                      -+- rx -+-
**
**                 Mundane Graphics API.
**
**  *--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*
**  Copyright(C) Dayan Rodriguez, 2022, All Rights Reserved
**  *--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*
**
**        NOT PRODUCTION READY/NOT PRODUCTION QUALITY
**
**
**               HONI SOIT QUI MAL Y PENSE
**
**                 github.com/MicroRJ/rx
**
*/

/*
** Libraries that you should use instead:
** sokol or tigr or raylib or virtually any other library that isn't this one.
**
** ** panic notes **
** - I DON'T SEE ANYTHING:
**   - Ensure that the pixel shader is not the problem first, make it return a solid color, like white,
**     if it does show, ensure the alpha channel is set.
**   - Ensure the render stack is configured properly, see note below to ensure how.
**   - Ensure your constant, vertex and index buffers contain valid data, you can check all this quite
**     trivially in the amazing 'Render Doc' for free!
**     - Select the 'Event Browser' window, (You can toggle windows under the 'Window' menu)
**         - First look at your draw calls, ensure you have a 'ClearRenderTarget()', 'Present()' and
**           at least a draw instruction, such as 'DrawIndexed(6)', if you don't it means you forgot
**           missed some code.
**         - For further inspection, select a draw event, such as 'DrawIndexed(..)'
**           - First, go to the 'Pipeline Stage' window, click the vertex and then the pixel shader stages to ensure
**             that all required resources are properly bound in their corresponding slots.
**              - You can click on the texture or resource to view its contents.
**           - Then, to verify that the per vertex data is proper, click on the 'Mesh Viewer' window,
**             you can see the projected inputs and outputs of the vertex shader, use this window to ensure
**             everything is properly set.
**           - If applicable, ensure the 'w' component of your vectors is properly set, if not sure, edit
**              the vertex shader and manually set to .5.
**   - If you're sure the problem is not the data nor the shaders, then it will most likely be a pipeline configuration
**     mistake, check the blend state first, then the rasterizer state.
**      - Ensure there's at least one blend state properly configured, if you're not sure disable blending
**        altogether to use d3d's default blend state.
**      - If clipping enabled, ensure you've got a clip set big enough for your scene, if not sure, disable
**        clipping altogether by not setting the rasterizer.
**      - Ensure your view-port is properly set!
**   - If you still don't see anything, try changing the clear color to something different, if you don't
**     see that color, then it could be a driver error, in which case, run Visual Studio's Graphic Debugger.
*/
// todo: bind different textures to the shader to avoid having to switch them multiple times per frame?
#ifndef _RX_H
#define _RX_H

# ifndef _RX_NO_WINDOWS
# pragma comment(lib,"user32")
# define             NOMINMAX
# define  WIN32_LEAN_AND_MEAN
# define _NO_CRT_STDIO_INLINE
#include     <windows.h>
#include    <Windowsx.h>
#  endif

#pragma comment(lib,        "Gdi32")
#pragma comment(lib,       "dxguid")
#pragma comment(lib,        "d3d11")
#pragma comment(lib,  "d3dcompiler")

# define CINTERFACE
# define COBJMACROS
# define D3D11_NO_HELPERS
/* suppress some warnings generated by d3dcompiler.h */
# pragma warning(push)
# pragma warning(disable:4115)
#include <d3dcompiler.h>
# pragma warning(pop)
/* suppress some warnings generated by d3d11.h */
# pragma warning(push)
# pragma warning(disable:4201)
// #include       <d3d11.h>
#include     <d3d11_3.h>
# pragma warning(pop)

#include   <dxgidebug.h>
#include        <dxgi.h>
#include     <dxgi1_3.h>

#ifndef lgi__deallocate_memory
#define lgi__deallocate_memory(memory,user) ((void)(user),free(memory))
#endif
#ifndef lgi__allocate_memory
#define lgi__allocate_memory(size,user) ((void)(user),malloc(size))
#endif
#ifndef lgi__reallocate_memory
#define lgi__reallocate_memory(size,memory,user) ((void)(user),realloc(size,memory))
#endif

#define lgi__allocate_typeof(T) ((T*)lgi__allocate_memory(sizeof(T),NULL))
#define lgi__clear_typeof(T) (memset(T,0,sizeof(*T)))

#define lgi_logTrace(fmt,...) printf("lgi trace: " fmt "\n", __VA_ARGS__)
#define lgi_logError(fmt,...) printf("lgi error: " fmt "\n", __VA_ARGS__)

#define lgi_API static
#define lgi_Global static

typedef int lgi_Bool;
#define lgi_Null NULL
#define lgi_True  ((lgi_Bool) 1)
#define lgi_False ((lgi_Bool) 0)

#define lgi_PI  3.14159
#define lgi_TAU 6.28318

// todo: enhance these assertions? ...
#ifndef lgi_ensure
# ifdef _DEBUG
#  define lgi_ensure(is_true,...) do{ if(!(is_true)) { lgi_logError("assertion triggered"); __debugbreak(); } } while(0)
# else
#  define lgi_ensure(is_true,...) lgi_Null
# endif
#endif


// TODO: rid of this!
#ifndef isWithin
#define isWithin(x,l,r) (((x)>=(l))&&((x)<=(r)))
#endif
#define isWithin3(x,a0,a1,b0,b1,c0,c1) (isWithin(x,a0,a1) || isWithin(x,b0,b1) || isWithin(x,c0,c1))

// #if defined(_RX_STANDALONE)
// #error "this option is deprecated!"
// #endif

# ifndef STB_SPRINTF_IMPLEMENTATION
# define STB_SPRINTF_IMPLEMENTATION
#include <stb/stb_sprintf.h>
#  endif

#include <src/win32.c>
#include <src/dlb.c>

#ifndef STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_IMPLEMENTATION
#define STBI_MALLOC(size) lgi__allocate_memory(size,NULL)
#define STBI_REALLOC(size,memory) lgi__reallocate_memory(size,memory,NULL)
#define STBI_FREE(memory) lgi__deallocate_memory(memory,NULL)
#include <stb/stb_image.h>
#endif//STB_IMAGE_IMPLEMENTATION

#ifndef STB_IMAGE_WRITE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION
#define STBIW_MALLOC(size) lgi__allocate_memory(size,NULL)
#define STBIW_REALLOC(size,memory) lgi__reallocate_memory(size,memory,NULL)
#define STBIW_FREE(memory) lgi__deallocate_memory(memory,NULL)
#include <stb/stb_image_write.h>
#endif//STB_IMAGE_WRITE_IMPLEMENTATION

/* todo: this is to be embedded eventually */
#include  "rxps.hlsl"
#include  "rxvs.hlsl"
#include  "rxsdf.vs.hlsl"
#include  "rxtxt.ps.hlsl"
#include  "rxtxt_sdf.ps.hlsl"
#include  "rxsdf_cir.ps.hlsl"
#include  "rxsdf_box.ps.hlsl"

/* disabled warnings */
#pragma warning(push)
/* unreferenced stuff */
#pragma warning(disable:4100)
/* nameless structs and unions */
#pragma warning(disable:4201)
/* int to float float to int and truncation warnings */
#pragma warning(disable:4244)
#pragma warning(disable:4305)

/* delicacies of programming */
#ifndef lgi_T
#ifndef __cplusplus
#define lgi_T(T) (T)
#  else
#define lgi_T(T)
# endif//__cplusplus
# endif//lgi_T

#ifndef lgi_DEFAULT_WINDOW_WIDTH
#define lgi_DEFAULT_WINDOW_WIDTH CW_USEDEFAULT
# endif//lgi_DEFAULT_WINDOW_WIDTH

#ifndef lgi_DEFAULT_WINDOW_HEIGHT
#define lgi_DEFAULT_WINDOW_HEIGHT CW_USEDEFAULT
# endif//lgi_DEFAULT_WINDOW_HEIGHT


#ifndef lgi_COMMON_SHADER_BUILD_FLAGS
#define lgi_COMMON_SHADER_BUILD_FLAGS D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR|D3DCOMPILE_WARNINGS_ARE_ERRORS|D3DCOMPILE_ENABLE_STRICTNESS
#endif//lgi_COMMON_SHADER_BUILD_FLAGS

#ifndef lgi_DEFAULT_SHADER_BUILD_FLAGS
# ifdef lgi_DEBUGGABLE_SHADERS
#define lgi_DEFAULT_SHADER_BUILD_FLAGS lgi_COMMON_SHADER_BUILD_FLAGS|D3DCOMPILE_DEBUG|D3DCOMPILE_SKIP_OPTIMIZATION
#  else
#define lgi_DEFAULT_SHADER_BUILD_FLAGS lgi_COMMON_SHADER_BUILD_FLAGS|D3DCOMPILE_OPTIMIZATION_LEVEL3
# endif//lgi_DEBUGGABLE_SHADERS
# endif//lgi_DEFAULT_SHADER_BUILD_FLAGS


// TODO:
#ifndef _RX_MSAA
#define _RX_MSAA 1
# endif//_RX_MSAA
#ifndef _RX_REFRESH_RATE
#define _RX_REFRESH_RATE 60
# endif//_RX_REFRESH_RATE

typedef enum {
	lgi_Error_NONE = 0,
	lgi_Error_UNKNOWN,
	lgi_Error_CREATE_TEXTURE,
} lgi_Error;

typedef enum {
	lgi_Format_R8_UNORM 		  = DXGI_FORMAT_R8_UNORM,
	lgi_Format_R8G8B8A8_UNORM = DXGI_FORMAT_R8G8B8A8_UNORM
} lgi_Format;

#include <src/vec.c>

/*
**
**  NOLI SE TANGERE
**
*/
typedef rxvec4_t lgi_Color;

#ifndef lgi_RGBA
#define lgi_RGBA(R,G,B,A) lgi_T(lgi_Color){R,G,B,A}
# endif
#ifndef lgi_RGBA_U
#define lgi_RGBA_U(R,G,B,A) lgi_RGBA((R)/255.f,(G)/255.f,(B)/255.f,(A)/255.f)
# endif

#define lgi_Color__WHITE       lgi_RGBA_U(0xFF, 0xFF, 0xFF, 0xFF)
#define lgi_Color__BLACK       lgi_RGBA_U(0x00, 0x00, 0x00, 0xFF)
#define lgi_Color__RED         lgi_RGBA_U(0xFF, 0x00, 0x00, 0xFF)
#define lgi_Color__GREEN       lgi_RGBA_U(0x00, 0xFF, 0x00, 0xFF)
#define lgi_Color__BLUE        lgi_RGBA_U(0x00, 0x00, 0xFF, 0xFF)
#define lgi_Color__YELLOW      lgi_RGBA_U(0xFF, 0xFF, 0x00, 0xFF)
#define lgi_Color__CYAN        lgi_RGBA_U(0x00, 0xFF, 0xFF, 0xFF)
#define lgi_Color__MAGENTA     lgi_RGBA_U(0xFF, 0x00, 0xFF, 0xFF)
#define lgi_Color__ORANGE      lgi_RGBA_U(0xFF, 0xA5, 0x00, 0xFF)
#define lgi_Color__PURPLE      lgi_RGBA_U(0x80, 0x00, 0x80, 0xFF)
#define lgi_Color__PINK        lgi_RGBA_U(0xFF, 0xC0, 0xCB, 0xFF)
#define lgi_Color__LIME        lgi_RGBA_U(0x00, 0xFF, 0x00, 0xFF)
#define lgi_Color__TEAL        lgi_RGBA_U(0x00, 0x80, 0x80, 0xFF)
#define lgi_Color__SKY_BLUE    lgi_RGBA_U(0x87, 0xCE, 0xEB, 0xFF)
#define lgi_Color__GOLD        lgi_RGBA_U(0xFF, 0xD7, 0x00, 0xFF)
#define lgi_Color__INDIGO      lgi_RGBA_U(0x4B, 0x00, 0x82, 0xFF)
#define lgi_Color__SILVER      lgi_RGBA_U(0xC0, 0xC0, 0xC0, 0xFF)
#define lgi_Color__TURQUOISE   lgi_RGBA_U(0x40, 0xE0, 0xD0, 0xFF)
#define lgi_Color__CORAL       lgi_RGBA_U(0xFF, 0x7F, 0x50, 0xFF)
#define lgi_Color__ORCHID      lgi_RGBA_U(0xDA, 0x70, 0xD6, 0xFF)
#define lgi_Color__LAVENDER    lgi_RGBA_U(0xE6, 0xE6, 0xFA, 0xFF)
#define lgi_Color__MAROON      lgi_RGBA_U(0x80, 0x00, 0x00, 0xFF)
#define lgi_Color__NAVY        lgi_RGBA_U(0x00, 0x00, 0x80, 0xFF)
#define lgi_Color__OLIVE       lgi_RGBA_U(0x80, 0x80, 0x00, 0xFF)
#define lgi_Color__SALMON      lgi_RGBA_U(0xFA, 0x80, 0x72, 0xFF)
#define lgi_Color__AQUAMARINE  lgi_RGBA_U(0x7F, 0xFF, 0xD4, 0xFF)


enum {
	rx_kNONE = 0,
	rx_kESCAPE,
	rxKEY_kLEFT,rxKEY_kRIGHT,rxKEY_kUP,rxKEY_kDOWN,
	rxKEY_kF1,rxKEY_kF2,rxKEY_kF3,rxKEY_kF4,rxKEY_kF5,
	rxKEY_kF6,rxKEY_kF7,rxKEY_kF8,rxKEY_kF9,
	rxKEY_kF10,rxKEY_kF11,rxKEY_kF12,
	rxKEY_kRETURN,
	rx_kLCTRL,rx_kRCTRL,
	rx_kLSFHT,rx_kRSFHT,
	rx_kBCKSPC,rx_kDELETE,
	rx_kHOME,rx_kEND,
	rxKEY_kSPACE = ' ',
	rxKEY_kA     = 'A',
	rxKEY_kZ     = 'Z',
	rxKEY_k0     = '0',
	rxKEY_k9     = '9',
};


typedef struct lgi_Bitmap lgi_Bitmap;

#include <src/rxgpu.h>
#include <src/rximp.h>

typedef struct lgi_Core lgi_Core;
typedef struct lgi_Core {

	/* timing stuff */
	__int64 frame_count;
	unsigned __int64   start_ticks;
	unsigned __int64   frame_ticks;
	unsigned __int64   total_ticks;
	unsigned __int64   delta_ticks;

	/* [[TODO]]: there are more correct and robust ways to store time long term, @TomForsyth */
	double          total_seconds;
	double          delta_seconds;

	/* todo: constants, should be upper case */
	lgi_Sampler linear_sampler;
	lgi_Sampler point_sampler;
	lgi_Sampler anisotropic_sampler;


	struct {
		struct {
			ID3D11InfoQueue        *inf;
			ID3D11Device           *dev;
			ID3D11DeviceContext    *ctx;
		};
		// todo: gpu.d3d11
	} d3d11;

	/* window related structure, we only support one window for now but it'd be
		trivial to extend this */
	struct {
		unsigned  off: 1;
		unsigned  vis: 1;

		struct {
			int size_x;
			int size_y;
			int center_x;
			int center_y;
		};

		struct {
			HWND handle;
		} win32;

		/* output media */
		struct {
			lgi_Texture *tar;

			struct {
				IDXGISwapChain2 *swap_chain;
				void            *frame_await;
			} d3d11;
		} out;

		/* input handling members, these get updated once every tick */
		struct {
			struct {
/* todo: store this better - rj */
				int chr;

/* todo: store this better */
				char     key_lst[0x100];
				char     key    [0x100];

				unsigned is_ctrl: 1;
				unsigned is_menu: 1;
				unsigned is_shft: 1;
			} kbrd;
			struct {
				int xcursor;
				int ycursor;
				int yscroll;
				int xscroll;

				int  xclick;
				int  yclick;

				int btn_old;
				int btn_cur;
			} mice;
		} in;
	} wnd;

	struct {
		HMODULE user32_dll;
		struct {
			HCURSOR arrow;
		} cursor;
	} win32;


	rxIMP_Context   imp;

	/* [[NOTE]]: not sure how well this is going to work in the long run */
#ifdef RX_EXTENSION_SLOT_0
	RX_EXTENSION_SLOT_0;
#endif
#ifdef RX_EXTENSION_SLOT_1
	RX_EXTENSION_SLOT_1;
#endif
} lgi_Core;

/* the source of all evil is here */
lgi_Global lgi_Core rx;

#include <src/rxgpu.c>
#include <src/rximp.c>

/* [[TODO]]:
	This is temporary */
void
lgi_OS__unloadFileContents(LPVOID fileContents) {
	VirtualFree(fileContents,0,MEM_RELEASE);
}

/* [[TODO]]:
	This is temporary */
void *
lgi_OS__loadFileContents(char const *fileName, __int32 *lpSize) {
	*lpSize = 0;
	char *lpBuffer = lgi_Null;
	HANDLE hFile = CreateFileA(fileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0x00,NULL);
	if (hFile != INVALID_HANDLE_VALUE) {
		DWORD highFileSize;
		DWORD lowFileSize = GetFileSize(hFile,&highFileSize);
		lpBuffer = VirtualAlloc(NULL,lowFileSize,MEM_COMMIT|MEM_RESERVE,0);
		DWORD bytesRead;
		if (ReadFile(hFile,lpBuffer,lowFileSize,&bytesRead,NULL) != FALSE) {
			*lpSize = bytesRead;
		} else {
			lgi_OS__unloadFileContents(lpBuffer);
			lpBuffer = lgi_Null;
		}
		CloseHandle(hFile);
	}
	return lpBuffer;
}

lgi_Shader
lgi_loadShader(int flags, char const *label, char const *entry, char const *fileName) {

	__int32 length = 0;
	void *memory = lgi_OS__loadFileContents(fileName,&length);

	lgi_Shader_Config config;
	ZeroMemory(&config,sizeof(config));
	config.flags = flags;
	config.label = label;
	config.source.compile.memory = memory;
	config.source.compile.length = length;
	config.source.compile.entry = entry;

	lgi_Shader shader;
	lgi_GPU__createShader(&shader,&config);

	lgi_OS__unloadFileContents(memory);
	return shader;
}

lgi_Texture *
lgi_uploadTextureContents(lgi_Bitmap image) {
	return lgi_GPU__createTextureSimply(image.size_x,image.size_y,image.format,image.stride,image.memory);
}

lgi_Bitmap
lgi_makeBitmap(int size_x, int size_y, int format) {
	int bpp = 0;
	if (format == lgi_Format_R8_UNORM) {
		bpp = 1;
	} else
	if (format == lgi_Format_R8G8B8A8_UNORM) {
		bpp = 4;
	}
	size_t size = size_y * size_x * bpp;

	lgi_ensure(bpp != 0);

	lgi_Bitmap result;
	result.size_x = size_x;
	result.size_y = size_y;
	result.format = format;
	result.stride = size_x * bpp;
	result.memory = lgi__allocate_memory(size, NULL);
	memset(result.memory,0,size);

	return result;
}

lgi_Bitmap
lgi_loadTextureContents(const char *name) {

	lgi_Bitmap result;
	ZeroMemory(&result,sizeof(result));

	/* XXX use own memory */
	void *memory=stbi_load(name,&result.size_x,&result.size_y,0,4);

	result.format=lgi_Format_R8G8B8A8_UNORM;
	result.memory=memory;
	result.stride=result.size_x*4;
	return result;
}

unsigned __int64
lgi_OS__queryClockFrequency() {
	LARGE_INTEGER l;
	QueryPerformanceFrequency(&l);
	return l.QuadPart;
}

unsigned __int64
lgi_OS__queryClock() {
	LARGE_INTEGER l;
	QueryPerformanceCounter(&l);
	return l.QuadPart;
}

void rx_pollClock() {

	/* todo: */
	unsigned __int64 freq = lgi_OS__queryClockFrequency();
	unsigned __int64 ticks = lgi_OS__queryClock();
	rx.total_ticks = ticks-rx.start_ticks;
	rx.total_seconds = rx.total_ticks / (double) freq;
	rx.delta_ticks=ticks-rx.frame_ticks;
	rx.delta_seconds = rx.delta_ticks / (double) freq;
	rx.frame_ticks=ticks;
}

int
rx_window_message_handler_win32(UINT,WPARAM,LPARAM);

LRESULT CALLBACK
rx_window_message_callback_win32(HWND,UINT,WPARAM,LPARAM);

/* todo: rename */
#ifndef       WAS_DOWN
#define       WAS_DOWN(x) ((rx.wnd.in.mice.btn_old & (1 << x)) != 0)
# endif
#ifndef        IS_DOWN
#define        IS_DOWN(x) ((rx.wnd.in.mice.btn_cur & (1 << x)) != 0)
# endif
#ifndef IS_CLICK_LEAVE
#define IS_CLICK_LEAVE(x) !IS_DOWN(x) &&  WAS_DOWN(x)
# endif
#ifndef IS_CLICK_ENTER
#define IS_CLICK_ENTER(x)  IS_DOWN(x) && !WAS_DOWN(x)
# endif

#define lgi_testCtrlKey() (rx.wnd.in.kbrd.is_ctrl != 0)
#define rx_testAltKey() (rx.wnd.in.kbrd.is_menu != 0)
#define rx_testShiftKey() (rx.wnd.in.kbrd.is_shft != 0)
#define lgi_testKey(xx) (rx.wnd.in.kbrd.key[xx] != 0)
#define lgi_testFKey(xx) (lgi_testKey(rxKEY_kF1 + iclamp(xx,1,12)-1))

int
rx_testChar() {
	return rx.wnd.in.kbrd.chr;
}

/* todo: this is provisional */
void
rxGPU_set_clip(int x0, int y0, int x1, int y1) {
	lgi_ensure(x0 <= x1);
	lgi_ensure(y0 <= y1);

	x0 = iclamp(x0,0,rx.wnd.size_x);
	y0 = iclamp(y0,0,rx.wnd.size_y);
	x1 = iclamp(x1,0,rx.wnd.size_x);
	y1 = iclamp(y1,0,rx.wnd.size_y);

	D3D11_RECT rect_d3d;
	rect_d3d.left  = x0;
	rect_d3d.top   = rx.wnd.size_y - y1;
	rect_d3d.right = x1;
	rect_d3d.bottom= rx.wnd.size_y - y0;
	ID3D11DeviceContext_RSSetScissorRects(rx.d3d11.ctx,1,&rect_d3d);
}

int
lgi_poll() {
	/* todo: */
	memcpy(rx.wnd.in.kbrd.key_lst,rx.wnd.in.kbrd.key,sizeof(rx.wnd.in.kbrd.key));
	memset(rx.wnd.in.kbrd.key,                     0,sizeof(rx.wnd.in.kbrd.key));
	rx.wnd.in.kbrd.chr = 0;

	rx.wnd.in.mice.yscroll = 0;
	rx.wnd.in.mice.xscroll = 0;
	rx.wnd.in.mice.btn_old = rx.wnd.in.mice.btn_cur;
	rx.wnd.in.mice.btn_cur = 0;

	MSG message;
	while (PeekMessage(&message,NULL,0,0,PM_REMOVE)) {
		TranslateMessage(&message);
		DispatchMessageW(&message);
	}

	RECT client;
	if (GetClientRect(rx.wnd.win32.handle,&client)) {
		rx.wnd.size_x = client. right - client.left;
		rx.wnd.size_y = client.bottom - client. top;
		rx.wnd.center_x=rx.wnd.size_x>>1;
		rx.wnd.center_y=rx.wnd.size_y>>1;
	}

	return !rx.wnd.off;
}

lgi_API int
lgi_tick() {

	rx.frame_count += 1;

	lgi_poll();

	/* todo */
	SetCursor(rx.win32.cursor.arrow);

	lgi_flushImmediatly();

	/* this has to be formalized #todo */
	rxGPU_copyTexture(rx.wnd.out.tar,rx.imp.pip.out.color[0]);

	if (rx.wnd.vis != TRUE) {
		ShowWindow(rx.wnd.win32.handle,SW_SHOW);
		rx.wnd.vis = TRUE;
	}

	if (rx.wnd.vis != FALSE) {

		HRESULT error = IDXGISwapChain_Present(rx.wnd.out.d3d11.swap_chain,1u,0);

		if FAILED(error) {
			return FALSE;
		}

		/* this does not serve any purpose in full screen mode */
		// WaitForSingleObjectEx(rx.wnd.out.d3d11.frame_await,INFINITE,TRUE);
	}


	float clear_color[] = {.0f,.0f,.0f,1.f};
	ID3D11DeviceContext_ClearDepthStencilView(rx.d3d11.ctx,rx.imp.pip.out.depth->d3d11.depth_target,D3D11_CLEAR_DEPTH|D3D11_CLEAR_STENCIL,1.0f,0);
	for(int i=0; i<rx.imp.pip.out.count; i+=1) {
		ID3D11DeviceContext_ClearRenderTargetView(rx.d3d11.ctx,rx.imp.pip.out.color[i]->d3d11.color_target,clear_color);
	}


	rx_pollClock();

	return !rx.wnd.off;
}

lgi_API void
lgi_initWindowed(int window_width, int window_height, char const *window_title) {

	typedef BOOL (WINAPI * XXX)(HANDLE);

	rx.win32.user32_dll = LoadLibraryA("user32.dll");

	XXX SetProcessDpiAwarenessContext = (XXX) GetProcAddress(rx.win32.user32_dll, "SetProcessDpiAwarenessContext");
	SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);

	rx.win32.cursor.arrow = LoadCursorA(NULL,IDC_ARROW);

	UINT flags =
#ifdef RX_DEBUG_DEVICE
/* note: comment this out to use intel's graphic analyzer utility (I'd rather use RenderDoc instead) */
	D3D11_CREATE_DEVICE_DEBUG|
	D3D11_CREATE_DEVICE_SINGLETHREADED|
#endif
	D3D11_CREATE_DEVICE_BGRA_SUPPORT;

	D3D_FEATURE_LEVEL feature_menu[2][2]= {
		{D3D_FEATURE_LEVEL_11_1,D3D_FEATURE_LEVEL_11_0},
		{D3D_FEATURE_LEVEL_10_1,D3D_FEATURE_LEVEL_10_0},
	};

	D3D_FEATURE_LEVEL feature_level;

	HRESULT error = D3D11CreateDevice(NULL,D3D_DRIVER_TYPE_HARDWARE,0,flags,feature_menu[0],
	ARRAYSIZE(feature_menu[0]),D3D11_SDK_VERSION,&rx.d3d11.dev,&feature_level,&rx.d3d11.ctx);

	if FAILED(error) {
		error = D3D11CreateDevice(NULL,D3D_DRIVER_TYPE_WARP,0,flags,feature_menu[1],
		ARRAYSIZE(feature_menu[1]),D3D11_SDK_VERSION,&rx.d3d11.dev,&feature_level,&rx.d3d11.ctx);
	}

#if defined(RX_DEBUG_DEVICE)
	if SUCCEEDED(error) {
		error = IUnknown_QueryInterface(rx.d3d11.dev,&IID_ID3D11InfoQueue,(void**)&rx.d3d11.inf);
		if SUCCEEDED(error) {
			ID3D11InfoQueue_SetBreakOnSeverity(rx.d3d11.inf, D3D11_MESSAGE_SEVERITY_CORRUPTION, TRUE);
			ID3D11InfoQueue_SetBreakOnSeverity(rx.d3d11.inf, D3D11_MESSAGE_SEVERITY_ERROR,      TRUE);
			ID3D11InfoQueue_SetBreakOnSeverity(rx.d3d11.inf, D3D11_MESSAGE_SEVERITY_WARNING,    TRUE);
		}
	}
#endif
	lgi_ensure(SUCCEEDED(error));

	wchar_t unicode_window_title[MAX_PATH];
	MultiByteToWideChar(CP_ACP,0,window_title,-1,unicode_window_title,MAX_PATH);

	WNDCLASSW wnd_class;
	ZeroMemory(&wnd_class,sizeof(wnd_class));
	wnd_class.lpfnWndProc=rx_window_message_callback_win32;
	wnd_class.hInstance=GetModuleHandleW(NULL);
	wnd_class.lpszClassName=unicode_window_title;
	if (RegisterClassW(&wnd_class)) {
		window_width = window_width != 0 ? window_width  : lgi_DEFAULT_WINDOW_WIDTH;
		window_height = window_height != 0 ? window_height : lgi_DEFAULT_WINDOW_HEIGHT;

		window_width = window_width != CW_USEDEFAULT ? window_width : 720;
		window_height = window_height != CW_USEDEFAULT ? window_height : 720;

		RECT wnd_rect;
		wnd_rect.left=0;
		wnd_rect.top=0;
		wnd_rect.right=window_width;
		wnd_rect.bottom=window_height;
		AdjustWindowRect(&wnd_rect,WS_OVERLAPPEDWINDOW,FALSE);

		window_width = wnd_rect. right - wnd_rect.left;
		window_height = wnd_rect.bottom - wnd_rect. top;
		lgi_logTrace("create window %ix%i",window_width,window_height);

		/* This makes the window not resizable */
		// &~WS_THICKFRAME
		rx.wnd.win32.handle = CreateWindowExW(WS_EX_NOREDIRECTIONBITMAP,wnd_class.lpszClassName,unicode_window_title,WS_OVERLAPPEDWINDOW,0,0,window_width,window_height,NULL,NULL,wnd_class.hInstance,NULL);
	}

	/* [[!]]:
		Poll here to get the window dimensions, which are needed to create some
		window dependent resources */
	lgi_poll();

	IDXGIDevice * device_dxgi = NULL;
	IDXGIAdapter * adapter_dxgi = NULL;
	IDXGIFactory2 * factory_dxgi = NULL;

	ID3D11Device_QueryInterface(rx.d3d11.dev,&IID_IDXGIDevice,(void **)&device_dxgi);
	IDXGIDevice_GetAdapter(device_dxgi,&adapter_dxgi);
	IDXGIAdapter_GetParent(adapter_dxgi,&IID_IDXGIFactory2,(void**)&factory_dxgi);

	// DXGI_USAGE_UNORDERED_ACCESS
	DXGI_SWAP_CHAIN_DESC1 sc_config_d3d;
	ZeroMemory(&sc_config_d3d,sizeof(sc_config_d3d));
	sc_config_d3d.Width=rx.wnd.size_x;
	sc_config_d3d.Height=rx.wnd.size_y;
	sc_config_d3d.Format=DXGI_FORMAT_R8G8B8A8_UNORM;
	sc_config_d3d.BufferUsage=DXGI_USAGE_RENDER_TARGET_OUTPUT;
	sc_config_d3d.BufferCount=2;
	sc_config_d3d.SwapEffect=DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
	// ResizeBuffers conflicts with this flag :(
	// |DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
	sc_config_d3d.Flags=DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
	/* todo: allow the user to specify this */
	sc_config_d3d.SampleDesc.  Count=1;
	sc_config_d3d.SampleDesc.Quality=0;

	DXGI_SWAP_CHAIN_FULLSCREEN_DESC sc_fs_config;
	ZeroMemory(&sc_fs_config,sizeof(sc_fs_config));
	sc_fs_config.RefreshRate.Numerator=_RX_REFRESH_RATE;
	sc_fs_config.RefreshRate.Denominator=1;
	sc_fs_config.Windowed=TRUE;

	error = IDXGIFactory2_CreateSwapChainForHwnd(factory_dxgi,(IUnknown *)rx.d3d11.dev,rx.wnd.win32.handle,&sc_config_d3d,&sc_fs_config,NULL,(IDXGISwapChain1 **)&rx.wnd.out.d3d11.swap_chain);
	lgi_ensure(SUCCEEDED(error));

	ID3D11Texture2D *texture_d3d;
	error = IDXGISwapChain_GetBuffer(rx.wnd.out.d3d11.swap_chain,0,&IID_ID3D11Texture2D,(void **)&texture_d3d);
	lgi_ensure(SUCCEEDED(error));
	// rxGPU_delete_texture(rx.imp.pip.out.color[0]);
	// rxGPU_delete_texture(rx.imp.pip.out.depth);
	// rxGPU_delete_texture(rx.wnd.out.tar);
	// __debugbreak();
	// ID3D11DeviceContext_ClearState(rx.d3d11.ctx);
	// error = IDXGISwapChain_ResizeBuffers(rx.wnd.out.d3d11.swap_chain,sc_config_d3d.BufferCount,512,512,sc_config_d3d.Format,0);


	// rx.wnd.out.d3d11.frame_await = IDXGISwapChain2_GetFrameLatencyWaitableObject(rx.wnd.out.d3d11.swap_chain);

	rxGPU_TEXTURE config;
	ZeroMemory(&config,sizeof(config));
	config.memtype = D3D11_USAGE_DEFAULT;
	config.useflag = D3D11_BIND_RENDER_TARGET;
	config.size_x = sc_config_d3d. Width;
	config.size_y = sc_config_d3d.Height;
	config.format = sc_config_d3d.Format;
	config.d3d11.texture_2d = texture_d3d;

	rx.wnd.out.tar = rxGPU_create_texture_ex(&config);

	IDXGIFactory_Release(factory_dxgi);
	IDXGIAdapter_Release(adapter_dxgi);
	IDXGIDevice_Release(device_dxgi);

	rxIMP_init();

	rxGPU_set_clip(0,0,rx.wnd.size_x,rx.wnd.size_y);

	D3D11_VIEWPORT viewport_d3d;
	viewport_d3d.TopLeftX=0;
	viewport_d3d.TopLeftY=0;
	viewport_d3d.   Width=rx.wnd.size_x;
	viewport_d3d.  Height=rx.wnd.size_y;
	viewport_d3d.MinDepth=0;
	viewport_d3d.MaxDepth=1;
	ID3D11DeviceContext_RSSetViewports(rx.d3d11.ctx,1,&viewport_d3d);

	rx.start_ticks=lgi_OS__queryClock();
	rx.frame_ticks=rx.start_ticks;

	lgi_poll();
}

LRESULT CALLBACK
rx_window_message_callback_win32(HWND Window,UINT Message,WPARAM wParam,LPARAM lParam) {
	LRESULT result = rx_window_message_handler_win32(Message,wParam,lParam);
	if(result != TRUE) {
		result = DefWindowProcW(Window,Message,wParam,lParam);
	}
	return result;
}

int
rx_window_message_handler_win32(UINT Message, WPARAM wParam, LPARAM lParam) {
	switch(Message) {
		case WM_CLOSE:
		case WM_QUIT: {
			PostQuitMessage(0);
			rx.wnd.off = TRUE;
		} break;
		case WM_SIZE: {
			RECT client;
			if (GetClientRect(rx.wnd.win32.handle,&client)) {
				int size_x = client. right - client.left;
				int size_y = client.bottom - client. top;

				if (rx.wnd.size_x != size_x || rx.wnd.size_y != size_y) {
					rx.wnd.size_x = size_x;
					rx.wnd.size_y = size_y;
					rx.wnd.center_x=size_x>>1;
					rx.wnd.center_y=size_y>>1;

					D3D11_VIEWPORT viewport_d3d;
					viewport_d3d.TopLeftX=0;
					viewport_d3d.TopLeftY=0;
					viewport_d3d.   Width=size_x;
					viewport_d3d.  Height=size_y;
					viewport_d3d.MinDepth=0;
					viewport_d3d.MaxDepth=1;
					ID3D11DeviceContext_RSSetViewports(rx.d3d11.ctx,1,&viewport_d3d);

					// rxGPU_delete_texture(rx.imp.pip.out.color[0]);
					// rxGPU_delete_texture(rx.imp.pip.out.depth);
					// rxGPU_delete_texture(rx.wnd.out.tar);
					// HRESULT error = IDXGISwapChain_ResizeBuffers(rx.wnd.out.d3d11.swap_chain,0,size_x,size_y,DXGI_FORMAT_UNKNOWN,0);
					// if SUCCEEDED(error) {
					// 	// __debugbreak();
					// } else {
					// 	__debugbreak();
					// }
					rxGPU_set_clip(0,0,size_x,size_y);
				}

				/* [[TODO]] */
				// rx.imp.pip.out.count = 1;
				// rx.imp.pip.out.color[0] = rxGPU_create_color_target(rx.wnd.out.tar->size_x,rx.wnd.out.tar->size_y,rx.wnd.out.tar->format,_RX_MSAA,0);
				// rx.imp.pip.out.depth    = rxGPU_create_depth_target(rx.wnd.out.tar->size_x,rx.wnd.out.tar->size_y,DXGI_FORMAT_D32_FLOAT);




				#if 0
				rxGPU_TEXTURE config;
				ZeroMemory(&config,sizeof(config));
				config.memtype = D3D11_USAGE_DEFAULT;
				config.useflag = D3D11_BIND_RENDER_TARGET;
				config.size_x = sc_config_d3d. Width;
				config.size_y = sc_config_d3d.Height;
				config.format = sc_config_d3d.Format;
				config.d3d11.texture_2d = texture_d3d;

				rx.wnd.out.tar = rxGPU_create_texture_ex(&config);
				#endif
			}
		} break;
		case WM_MOUSEMOVE: {
			int xcursor=GET_X_LPARAM(lParam);
			int ycursor=GET_Y_LPARAM(lParam);
			rx.wnd.in.mice.xcursor=xcursor;
			rx.wnd.in.mice.ycursor=rx.wnd.size_y-ycursor;
		} break;
		case WM_MOUSEWHEEL: {
			rx.wnd.in.mice.yscroll = GET_WHEEL_DELTA_WPARAM(wParam)/WHEEL_DELTA;
		} break;
// SetCapture((HWND)rx.wnd.win32.handle);
		case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK: case WM_LBUTTONUP: {
			rx.wnd.in.mice.btn_cur |= (Message!=WM_LBUTTONUP) << 0;
		} break;
		case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK: case WM_RBUTTONUP: {
			rx.wnd.in.mice.btn_cur |= (Message!=WM_RBUTTONUP) << 1;
		} break;
// ReleaseCapture();
		case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK: case WM_MBUTTONUP: {
			rx.wnd.in.mice.btn_cur |= (Message!=WM_MBUTTONUP) << 2;
		} break;
		case WM_CHAR: {
			rx.wnd.in.kbrd.chr = wParam;
		} break;
		case WM_SYSKEYUP: case WM_SYSKEYDOWN: case WM_KEYUP: case WM_KEYDOWN: {
			/* todo: there's probably a better way to do this */
			rx.wnd.in.kbrd.is_shft = (GetKeyState(VK_SHIFT)   & 0x8000) != 0;
			rx.wnd.in.kbrd.is_ctrl = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
			rx.wnd.in.kbrd.is_menu = (GetKeyState(VK_MENU)    & 0x8000) != 0;

			int key_map = 0;
			if isWithin3(wParam,'a','z','A','Z','0','9') {
				key_map = wParam;
			}

			switch(wParam) {
				case VK_CONTROL:    key_map = rx_kLCTRL;     break;
				case VK_RETURN:     key_map = rxKEY_kRETURN;    break;
				case VK_BACK:       key_map = rx_kBCKSPC;    break;
				case VK_DELETE:     key_map = rx_kDELETE;    break;
				case VK_HOME:       key_map = rx_kHOME;      break;
				case VK_END:        key_map = rx_kEND;       break;
				case VK_ESCAPE:     key_map = rx_kESCAPE;    break;

				case VK_LEFT:       key_map = rxKEY_kLEFT;  break;
				case VK_RIGHT:      key_map = rxKEY_kRIGHT; break;
				case VK_UP:         key_map = rxKEY_kUP;    break;
				case VK_DOWN:       key_map = rxKEY_kDOWN;  break;

				case VK_F1:  key_map = rxKEY_kF1;  break;
				case VK_F2:  key_map = rxKEY_kF2;  break;
				case VK_F3:  key_map = rxKEY_kF3;  break;
				case VK_F4:  key_map = rxKEY_kF4;  break;
				case VK_F5:  key_map = rxKEY_kF5;  break;
				case VK_F6:  key_map = rxKEY_kF6;  break;
				case VK_F7:  key_map = rxKEY_kF7;  break;
				case VK_F8:  key_map = rxKEY_kF8;  break;
				case VK_F9:  key_map = rxKEY_kF9;  break;
				case VK_F10: key_map = rxKEY_kF10; break;
				case VK_F11: key_map = rxKEY_kF11; break;
				case VK_F12: key_map = rxKEY_kF12; break;
				/* waste of time */
				case VK_SPACE:      key_map =  ' '; break;
				case VK_OEM_PLUS:   key_map =  '='; break;
				case VK_OEM_PERIOD: key_map =  '.'; break;
				case VK_OEM_COMMA:  key_map =  ','; break;
				case VK_OEM_1:      key_map =  ';'; break;
				case VK_OEM_2:      key_map =  '/'; break;
				case VK_OEM_3:      key_map =  '~'; break;
				case VK_OEM_4:      key_map =  '['; break;
				case VK_OEM_5:      key_map = '\\'; break;
				case VK_OEM_6:      key_map =  ']'; break;
				case VK_OEM_7:      key_map = '\''; break;
			}

			rx.wnd.in.kbrd.key[key_map] = (Message == WM_KEYDOWN) || (Message == WM_SYSKEYDOWN);
		} break;
		default: {
			return FALSE;
		}
	}
	return TRUE;
}

#pragma warning(pop)
#endif

