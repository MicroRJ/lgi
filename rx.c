/*
**
**                      -+- rx -+-
**
**                 Mundane Graphics API.
**
**  *--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*
**  Copyright(C) Dayan Rodriguez, 2022, All Rights Reserved
**  *--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*--*
**
**        NOT PRODUCTION READY/NOT PRODUCTION QUALITY
**
**
**               HONI SOIT QUI MAL Y PENSE
**
**                 github.com/MicroRJ/rx
**
*/

/*
** Libraries that you should use instead:
** sokol or tigr or raylib or virtually any other library that isn't this one.
**
** ** panic notes **
** - I DON'T SEE ANYTHING:
**   - Ensure that the pixel shader is not the problem first, make it return a solid color, like white,
**     if it does show, ensure the alpha channel is set.
**   - Ensure the render stack is configured properly, see note below to ensure how.
**   - Ensure your constant, vertex and index buffers contain valid data, you can check all this quite
**     trivially in the amazing 'Render Doc' for free!
**     - Select the 'Event Browser' window, (You can toggle windows under the 'Window' menu)
**         - First look at your draw calls, ensure you have a 'ClearRenderTarget()', 'Present()' and
**           at least a draw instruction, such as 'DrawIndexed(6)', if you don't it means you forgot
**           missed some code.
**         - For further inspection, select a draw event, such as 'DrawIndexed(..)'
**           - First, go to the 'Pipeline Stage' window, click the vertex and then the pixel shader stages to ensure
**             that all required resources are properly bound in their corresponding slots.
**              - You can click on the texture or resource to view its contents.
**           - Then, to verify that the per vertex data is proper, click on the 'Mesh Viewer' window,
**             you can see the projected inputs and outputs of the vertex shader, use this window to ensure
**             everything is properly set.
**           - If applicable, ensure the 'w' component of your vectors is properly set, if not sure, edit
**              the vertex shader and manually set to .5.
**   - If you're sure the problem is not the data nor the shaders, then it will most likely be a pipeline configuration
**     mistake, check the blend state first, then the rasterizer state.
**      - Ensure there's at least one blend state properly configured, if you're not sure disable blending
**        altogether to use d3d's default blend state.
**      - If clipping enabled, ensure you've got a clip set big enough for your scene, if not sure, disable
**        clipping altogether by not setting the rasterizer.
**      - Ensure your view-port is properly set!
**   - If you still don't see anything, try changing the clear color to something different, if you don't
**     see that color, then it could be a driver error, in which case, run Visual Studio's Graphic Debugger.
*/
// todo: bind different textures to the shader to avoid having to switch them multiple times per frame?
#ifndef _RX_H
#define _RX_H

# ifndef _RX_NO_WINDOWS
# pragma comment(lib,"user32")
# define             NOMINMAX
# define  WIN32_LEAN_AND_MEAN
# define _NO_CRT_STDIO_INLINE
#include     <windows.h>
#include    <Windowsx.h>
#  endif

#pragma comment(lib,        "Gdi32")
#pragma comment(lib,       "dxguid")
#pragma comment(lib,        "d3d11")
#pragma comment(lib,  "d3dcompiler")

# define CINTERFACE
# define COBJMACROS
# define D3D11_NO_HELPERS
/* suppress some warnings generated by d3dcompiler.h */
# pragma warning(push)
# pragma warning(disable:4115)
#include <d3dcompiler.h>
# pragma warning(pop)
/* suppress some warnings generated by d3d11.h */
# pragma warning(push)
# pragma warning(disable:4201)
// #include       <d3d11.h>
#include     <d3d11_3.h>
# pragma warning(pop)

#include   <dxgidebug.h>
#include        <dxgi.h>
#include     <dxgi1_3.h>

#ifndef EMU_MALLOC
#define EMU_MALLOC(size,user) ((void)(user),malloc(size))
#endif
#ifndef EMU_REALLOC
#define EMU_REALLOC(size,memory,user) ((void)(user),realloc(size,memory))
#endif
#ifndef EMU_FREE
#define EMU_FREE(memory,user) ((void)(user),free(memory))
#endif
#define EMU_ALLOC_TYPE(T) ((T*)EMU_MALLOC(sizeof(T),NULL))

#define rxLOG_trace(fmt,...) (0)
#define rxLOG_error(fmt,...) (0)

#define isWithin(x,l,r) (((x)>=(l))&&((x)<=(r)))
#define isWithin3(x,a0,a1,b0,b1,c0,c1) (isWithin(x,a0,a1) || isWithin(x,b0,b1) || isWithin(x,c0,c1))

#define rxAPI static
#define rxGlobal static

#define rxNull NULL
#define rxTrue  ((__int32) 1)
#define rxFalse ((__int32) 0)


#define rxPI_F 3.14159265358979323846f
#define rxPI   3.14159265358979323846
#define rxABS(v)   ((v)<(0)?-(v):(v))
#define rxMIN(x,y) ((x)<(y)? (x):(y))
#define rxMAX(x,y) ((x)>(y)? (x):(y))

// todo: enhance these assertions? ...
#ifndef rx_assert
# ifdef _DEBUG
#  define rx_assert(is_true,...) do{ if(!(is_true)) { rxLOG_error("assertion triggered",0); __debugbreak(); } } while(0)
# else
#  define rx_assert(is_true,...) rxNull
# endif
#endif

#if defined(_RX_STANDALONE)

# ifndef STB_SPRINTF_IMPLEMENTATION
# define STB_SPRINTF_IMPLEMENTATION
#include <stb/stb_sprintf.h>
#  endif

#include <src/dlb.c>

#define STB_IMAGE_IMPLEMENTATION
#define STBI_MALLOC(size) EMU_MALLOC(size,NULL)
#define STBI_REALLOC(size,memory) EMU_REALLOC(size,memory,NULL)
#define STBI_FREE(memory) EMU_FREE(memory,NULL)
#include <stb/stb_image.h>

#define STB_IMAGE_WRITE_IMPLEMENTATION
#define STBIW_MALLOC(size) EMU_MALLOC(size,NULL)
#define STBIW_REALLOC(size,memory) EMU_REALLOC(size,memory,NULL)
#define STBIW_FREE(memory) EMU_FREE(memory,NULL)
#include <stb/stb_image_write.h>
#endif//_RX_STANDALONE

/* todo: this is to be embedded eventually */
#include  "rxps.hlsl"
#include  "rxvs.hlsl"
#include  "rxsdf.vs.hlsl"
#include  "rxtxt.ps.hlsl"
#include  "rxtxt_sdf.ps.hlsl"
#include  "rxsdf_cir.ps.hlsl"
#include  "rxsdf_box.ps.hlsl"

/* disabled warnings */
#pragma warning(push)
/* unreferenced stuff */
#pragma warning(disable:4100)
/* nameless structs and unions */
#pragma warning(disable:4201)
/* int to float float to int and truncation warnings */
#pragma warning(disable:4244)
#pragma warning(disable:4305)

/* delicacies of programming */
#ifndef RX_TLIT
#ifndef __cplusplus
#define RX_TLIT(T) (T)
#  else
#define RX_TLIT(T)
# endif//__cplusplus
# endif//RX_TLIT

#ifndef _RX_DEFAULT_WINDOW_SIZE_X
#define _RX_DEFAULT_WINDOW_SIZE_X CW_USEDEFAULT
# endif//_RX_DEFAULT_WINDOW_SIZE_X
#ifndef _RX_DEFAULT_WINDOW_SIZE_Y
#define _RX_DEFAULT_WINDOW_SIZE_Y CW_USEDEFAULT
# endif//_RX_DEFAULT_WINDOW_SIZE_Y
#ifndef _RX_MSAA
#define _RX_MSAA 1
# endif//_RX_MSAA
#ifndef _RX_REFRESH_RATE
#define _RX_REFRESH_RATE 60
# endif//_RX_REFRESH_RATE

#ifndef RX_SHADER_COMPILATION_FLAGS
# ifdef RX_DEBUGGABLE_SHADERS
#define RX_SHADER_COMPILATION_FLAGS D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR|D3DCOMPILE_DEBUG|D3DCOMPILE_SKIP_OPTIMIZATION|D3DCOMPILE_WARNINGS_ARE_ERRORS
#else
#define RX_SHADER_COMPILATION_FLAGS D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR|D3DCOMPILE_ENABLE_STRICTNESS|D3DCOMPILE_OPTIMIZATION_LEVEL3
# endif//RX_DEBUGGABLE_SHADERS
# endif//RX_SHADER_COMPILATION_FLAGS

typedef enum {
	rxError_kNONE = 0,
	rxError_kUNKNOWN,
	rxError_kCREATE_TEXTURE,
} rxError;

enum {
	EMU_FORMAT_R8_UNORM 		  = DXGI_FORMAT_R8_UNORM,
	EMU_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT_R8G8B8A8_UNORM
};

#include <src/vec.c>

/*
**
**  NOLI SE TANGERE
**
*/
typedef rxvec4_t rlColor;

#ifndef rxColor_RGBA
#define rxColor_RGBA(R,G,B,A) RX_TLIT(rlColor){R,G,B,A}
# endif
#ifndef rxColor_RGBA_U
#define rxColor_RGBA_U(R,G,B,A) rxColor_RGBA((R)/255.f,(G)/255.f,(B)/255.f,(A)/255.f)
# endif

#define rxColor_WHITE         rxColor_RGBA_U(0xFF, 0xFF, 0xFF, 0xFF)
#define rxColor_BLACK         rxColor_RGBA_U(0x00, 0x00, 0x00, 0xFF)
#define rxColor_RED           rxColor_RGBA_U(0xFF, 0x00, 0x00, 0xFF)
#define rxColor_GREEN         rxColor_RGBA_U(0x00, 0xFF, 0x00, 0xFF)
#define rxColor_BLUE          rxColor_RGBA_U(0x00, 0x00, 0xFF, 0xFF)
#define rxColor_YELLOW        rxColor_RGBA_U(0xFF, 0xFF, 0x00, 0xFF)
#define rxColor_CYAN          rxColor_RGBA_U(0x00, 0xFF, 0xFF, 0xFF)
#define rxColor_MAGENTA       rxColor_RGBA_U(0xFF, 0x00, 0xFF, 0xFF)
#define rxColor_ORANGE        rxColor_RGBA_U(0xFF, 0xA5, 0x00, 0xFF)
#define rxColor_PURPLE        rxColor_RGBA_U(0x80, 0x00, 0x80, 0xFF)
#define rxColor_PINK          rxColor_RGBA_U(0xFF, 0xC0, 0xCB, 0xFF)
#define rxColor_LIME          rxColor_RGBA_U(0x00, 0xFF, 0x00, 0xFF)
#define rxColor_TEAL          rxColor_RGBA_U(0x00, 0x80, 0x80, 0xFF)
#define rxColor_SKY_BLUE      rxColor_RGBA_U(0x87, 0xCE, 0xEB, 0xFF)
#define rxColor_GOLD          rxColor_RGBA_U(0xFF, 0xD7, 0x00, 0xFF)
#define rxColor_INDIGO        rxColor_RGBA_U(0x4B, 0x00, 0x82, 0xFF)
#define rxColor_SILVER        rxColor_RGBA_U(0xC0, 0xC0, 0xC0, 0xFF)
#define rxColor_TURQUOISE     rxColor_RGBA_U(0x40, 0xE0, 0xD0, 0xFF)
#define rxColor_CORAL         rxColor_RGBA_U(0xFF, 0x7F, 0x50, 0xFF)
#define rxColor_ORCHID        rxColor_RGBA_U(0xDA, 0x70, 0xD6, 0xFF)
#define rxColor_LAVENDER      rxColor_RGBA_U(0xE6, 0xE6, 0xFA, 0xFF)
#define rxColor_MAROON        rxColor_RGBA_U(0x80, 0x00, 0x00, 0xFF)
#define rxColor_NAVY          rxColor_RGBA_U(0x00, 0x00, 0x80, 0xFF)
#define rxColor_OLIVE         rxColor_RGBA_U(0x80, 0x80, 0x00, 0xFF)
#define rxColor_SALMON        rxColor_RGBA_U(0xFA, 0x80, 0x72, 0xFF)
#define rxColor_AQUAMARINE    rxColor_RGBA_U(0x7F, 0xFF, 0xD4, 0xFF)


enum {
	rx_kNONE = 0,
	rx_kESCAPE,
	rxKEY_kLEFT,rxKEY_kRIGHT,rxKEY_kUP,rxKEY_kDOWN,
	rxKEY_kF1,rxKEY_kF2,rxKEY_kF3,rxKEY_kF4,rxKEY_kF5,
	rxKEY_kF6,rxKEY_kF7,rxKEY_kF8,rxKEY_kF9,
	rxKEY_kF10,rxKEY_kF11,rxKEY_kF12,
	rxKEY_kRETURN,
	rx_kLCTRL,rx_kRCTRL,
	rx_kLSFHT,rx_kRSFHT,
	rx_kBCKSPC,rx_kDELETE,
	rx_kHOME,rx_kEND,
	rxKEY_kSPACE = ' ',
	rxKEY_kA     = 'A',
	rxKEY_kZ     = 'Z',
	rxKEY_k0     = '0',
	rxKEY_k9     = '9',
};


typedef struct rx_Image rx_Image;

#include <src/rxgpu.h>
#include <src/rximp.h>

typedef struct rx_t rx_t;
typedef struct rx_t {

	/* timing stuff */
	__int64 frame_count;
	unsigned __int64   start_ticks;
	unsigned __int64   frame_ticks;
	unsigned __int64   total_ticks;
	unsigned __int64   delta_ticks;

	/* [[TODO]]: there are more correct and robust ways to store time long term, @TomForsyth */
	double          total_seconds;
	double          delta_seconds;

	/* todo: constants, should be upper case */
	rxGPU_Sampler linear_sampler;
	rxGPU_Sampler point_sampler;
	rxGPU_Sampler anisotropic_sampler;


	struct {
		struct {
			ID3D11InfoQueue        *inf;
			ID3D11Device           *dev;
			ID3D11DeviceContext    *ctx;
		};
		// todo: gpu.d3d11
	} d3d11;

	/* window related structure, we only support one window for now but it'd be
		trivial to extend this */
	struct {
		unsigned  off: 1;
		unsigned  vis: 1;

		struct {
			int size_x;
			int size_y;
			int center_x;
			int center_y;
		};

		struct {
			HWND handle;
		} win32;

		/* output media */
		struct {
			rxGPU_Texture *tar;

			struct {
				IDXGISwapChain2 *swap_chain;
				void            *frame_await;
			} d3d11;
		} out;

		/* input handling members, these get updated once every tick */
		struct {
			struct {
/* todo: store this better - rj */
				int chr;

/* todo: store this better */
				char     key_lst[0x100];
				char     key    [0x100];

				unsigned is_ctrl: 1;
				unsigned is_menu: 1;
				unsigned is_shft: 1;
			} kbrd;
			struct {
				int xcursor;
				int ycursor;
				int yscroll;
				int xscroll;

				int  xclick;
				int  yclick;

				int btn_old;
				int btn_cur;
			} mice;
		} in;
	} wnd;

	struct {
		HMODULE user32_dll;
		struct {
			HCURSOR arrow;
		} cursor;
	} win32;


	rxIMP_Context   imp;

	/* [[NOTE]]: not sure how well this is going to work in the long run */
#ifdef RX_EXTENSION_SLOT_0
	RX_EXTENSION_SLOT_0;
#endif
#ifdef RX_EXTENSION_SLOT_1
	RX_EXTENSION_SLOT_1;
#endif
} rx_t;

/* the source of all evil is here */
rxGlobal rx_t rx;

#include <src/rxgpu.c>
#include <src/rximp.c>

/* [[TODO]]:
	This is temporary */
void
rx_unloadFileContents(LPVOID fileContents) {
	VirtualFree(fileContents,0,MEM_RELEASE);
}

/* [[TODO]]:
	This is temporary */
void *
rx_loadFileContents(char const *fileName, __int32 *lpSize) {
	*lpSize = 0;
	char *lpBuffer = rxNull;
	HANDLE hFile = CreateFileA(fileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0x00,NULL);
	if (hFile != INVALID_HANDLE_VALUE) {
		DWORD highFileSize;
		DWORD lowFileSize = GetFileSize(hFile,&highFileSize);
		lpBuffer = VirtualAlloc(NULL,lowFileSize,MEM_COMMIT|MEM_RESERVE,0);
		DWORD bytesRead;
		if (ReadFile(hFile,lpBuffer,lowFileSize,&bytesRead,NULL) != FALSE) {
			*lpSize = bytesRead;
		} else {
			rx_unloadFileContents(lpBuffer);
			lpBuffer = rxNull;
		}
		CloseHandle(hFile);
	}
	return lpBuffer;
}

rxGPU_Shader
rx_loadShaderFromFile(int flags, char const *label, char const *entry, char const *fileName) {
	rxGPU_SHADER config;
	ZeroMemory(&config,sizeof(config));
	config.flags = flags;
	config.label = label;
	__int32 length = 0;
	void *memory = rx_loadFileContents(fileName,&length);
	config.source.compile.memory = memory;
	config.source.compile.length = length;
	config.source.compile.entry = entry;
	rxGPU_Shader shader;
	rxGPU_initShader(&shader,&config);
	rx_unloadFileContents(memory);
	return shader;
}

rxGPU_Texture *
rx_uploadimage(rx_Image image) {
	return rxGPU_create_texture(image.size_x,image.size_y,image.format,image.stride,image.memory);
}

rx_Image
rx_makeImage(int size_x, int size_y, int format) {
	int bpp = 0;
	if (format == EMU_FORMAT_R8_UNORM) {
		bpp = 1;
	} else
	if (format == EMU_FORMAT_R8G8B8A8_UNORM) {
		bpp = 4;
	}

	rx_assert(bpp != 0);

	rx_Image result;
	result.size_x = size_x;
	result.size_y = size_y;
	result.format = format;
	result.stride = size_x * bpp;
	result.memory = EMU_MALLOC(size_y * size_x * bpp, NULL);

	return result;
}

rx_Image
rx_loadimage(const char *name) {

	rx_Image result;
	ZeroMemory(&result,sizeof(result));

	/* XXX use own memory */
	void *memory=stbi_load(name,&result.size_x,&result.size_y,0,4);

	result.format=EMU_FORMAT_R8G8B8A8_UNORM;
	result.memory=memory;
	result.stride=result.size_x*4;
	return result;
}

unsigned __int64
rx_getClockFrequency() {

	LARGE_INTEGER l;
	QueryPerformanceFrequency(&l);
	return l.QuadPart;
}

unsigned __int64
rx_getClockTicks() {
	LARGE_INTEGER l;
	QueryPerformanceCounter(&l);
	return l.QuadPart;
}

void rx_pollClock() {

	/* todo: */
	unsigned __int64 freq = rx_getClockFrequency();
	unsigned __int64 ticks = rx_getClockTicks();
	rx.total_ticks = ticks-rx.start_ticks;
	rx.total_seconds = rx.total_ticks / (double) freq;
	rx.delta_ticks=ticks-rx.frame_ticks;
	rx.delta_seconds = rx.delta_ticks / (double) freq;
	rx.frame_ticks=ticks;
}

int
rx_window_message_handler_win32(UINT,WPARAM,LPARAM);

LRESULT CALLBACK
rx_window_message_callback_win32(HWND,UINT,WPARAM,LPARAM);

/* todo: rename */
#ifndef       WAS_DOWN
#define       WAS_DOWN(x) ((rx.wnd.in.mice.btn_old & (1 << x)) != 0)
# endif
#ifndef        IS_DOWN
#define        IS_DOWN(x) ((rx.wnd.in.mice.btn_cur & (1 << x)) != 0)
# endif
#ifndef IS_CLICK_LEAVE
#define IS_CLICK_LEAVE(x) !IS_DOWN(x) &&  WAS_DOWN(x)
# endif
#ifndef IS_CLICK_ENTER
#define IS_CLICK_ENTER(x)  IS_DOWN(x) && !WAS_DOWN(x)
# endif

#define rx_testCtrlKey() (rx.wnd.in.kbrd.is_ctrl != 0)
#define rx_testAltKey() (rx.wnd.in.kbrd.is_menu != 0)
#define rx_testShiftKey() (rx.wnd.in.kbrd.is_shft != 0)
#define rx_testKey(xx) (rx.wnd.in.kbrd.key[xx] != 0)
#define rx_testFKey(xx) (rx_testKey(rxKEY_kF1 + iclamp(xx,1,12)-1))

int
rx_testChar() {
	return rx.wnd.in.kbrd.chr;
}

/* todo: this is provisional */
void
rxGPU_set_clip(int x0, int y0, int x1, int y1) {
	rx_assert(x0 <= x1);
	rx_assert(y0 <= y1);

	x0 = iclamp(x0,0,rx.wnd.size_x);
	y0 = iclamp(y0,0,rx.wnd.size_y);
	x1 = iclamp(x1,0,rx.wnd.size_x);
	y1 = iclamp(y1,0,rx.wnd.size_y);

	D3D11_RECT rect_d3d;
	rect_d3d.left  = x0;
	rect_d3d.top   = rx.wnd.size_y - y1;
	rect_d3d.right = x1;
	rect_d3d.bottom= rx.wnd.size_y - y0;
	ID3D11DeviceContext_RSSetScissorRects(rx.d3d11.ctx,1,&rect_d3d);
}

int
rxpoll() {
	/* todo: */
	memcpy(rx.wnd.in.kbrd.key_lst,rx.wnd.in.kbrd.key,sizeof(rx.wnd.in.kbrd.key));
	memset(rx.wnd.in.kbrd.key,                     0,sizeof(rx.wnd.in.kbrd.key));
	rx.wnd.in.kbrd.chr = 0;

	rx.wnd.in.mice.yscroll = 0;
	rx.wnd.in.mice.xscroll = 0;
	rx.wnd.in.mice.btn_old = rx.wnd.in.mice.btn_cur;
	rx.wnd.in.mice.btn_cur = 0;

	MSG message;
	while (PeekMessage(&message,NULL,0,0,PM_REMOVE)) {
		TranslateMessage(&message);
		DispatchMessageW(&message);
	}

	RECT client;
	if (GetClientRect(rx.wnd.win32.handle,&client)) {
		rx.wnd.size_x = client. right - client.left;
		rx.wnd.size_y = client.bottom - client. top;
		rx.wnd.center_x=rx.wnd.size_x>>1;
		rx.wnd.center_y=rx.wnd.size_y>>1;
	}

	return !rx.wnd.off;
}

rxAPI int
rxtick() {

	rx.frame_count += 1;

	rxpoll();

	/* todo */
	SetCursor(rx.win32.cursor.arrow);

	rxIMP_flush();

	/* this has to be formalized #todo */
	rxGPU_copyTexture(rx.wnd.out.tar,rx.imp.pip.out.color[0]);

	if (rx.wnd.vis != TRUE) {
		ShowWindow(rx.wnd.win32.handle,SW_SHOW);
		rx.wnd.vis = TRUE;
	}

	if (rx.wnd.vis != FALSE) {

		HRESULT error = IDXGISwapChain_Present(rx.wnd.out.d3d11.swap_chain,1u,0);

		if FAILED(error) {
			return FALSE;
		}

		/* this does not serve any purpose in full screen mode */
		// WaitForSingleObjectEx(rx.wnd.out.d3d11.frame_await,INFINITE,TRUE);
	}


	float clear_color[] = {.0f,.0f,.0f,1.f};
	ID3D11DeviceContext_ClearDepthStencilView(rx.d3d11.ctx,rx.imp.pip.out.depth->d3d11.depth_target,D3D11_CLEAR_DEPTH|D3D11_CLEAR_STENCIL,1.0f,0);
	for(int i=0; i<rx.imp.pip.out.count; i+=1) {
		ID3D11DeviceContext_ClearRenderTargetView(rx.d3d11.ctx,rx.imp.pip.out.color[i]->d3d11.color_target,clear_color);
	}


	rx_pollClock();

	return !rx.wnd.off;
}

rxAPI void
init_windowed(int window_width, int window_height, char const *window_title) {

	typedef BOOL (WINAPI * XXX)(HANDLE);

	rx.win32.user32_dll = LoadLibraryA("user32.dll");

	XXX SetProcessDpiAwarenessContext = (XXX) GetProcAddress(rx.win32.user32_dll, "SetProcessDpiAwarenessContext");
	SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);

	rx.win32.cursor.arrow = LoadCursorA(NULL,IDC_ARROW);

	UINT flags =
#ifdef RX_DEBUG_DEVICE
/* note: comment this out to use intel's graphic analyzer utility (I'd rather use RenderDoc instead) */
	D3D11_CREATE_DEVICE_DEBUG|
	D3D11_CREATE_DEVICE_SINGLETHREADED|
#endif
	D3D11_CREATE_DEVICE_BGRA_SUPPORT;

	D3D_FEATURE_LEVEL feature_menu[2][2]= {
		{D3D_FEATURE_LEVEL_11_1,D3D_FEATURE_LEVEL_11_0},
		{D3D_FEATURE_LEVEL_10_1,D3D_FEATURE_LEVEL_10_0},
	};

	D3D_FEATURE_LEVEL feature_level;

	HRESULT error = D3D11CreateDevice(NULL,D3D_DRIVER_TYPE_HARDWARE,0,flags,feature_menu[0],
	ARRAYSIZE(feature_menu[0]),D3D11_SDK_VERSION,&rx.d3d11.dev,&feature_level,&rx.d3d11.ctx);

	if FAILED(error) {
		error = D3D11CreateDevice(NULL,D3D_DRIVER_TYPE_WARP,0,flags,feature_menu[1],
		ARRAYSIZE(feature_menu[1]),D3D11_SDK_VERSION,&rx.d3d11.dev,&feature_level,&rx.d3d11.ctx);
	}

#if defined(RX_DEBUG_DEVICE)
	if SUCCEEDED(error) {
		error = IUnknown_QueryInterface(rx.d3d11.dev,&IID_ID3D11InfoQueue,(void**)&rx.d3d11.inf);
		if SUCCEEDED(error) {
			ID3D11InfoQueue_SetBreakOnSeverity(rx.d3d11.inf, D3D11_MESSAGE_SEVERITY_CORRUPTION, TRUE);
			ID3D11InfoQueue_SetBreakOnSeverity(rx.d3d11.inf, D3D11_MESSAGE_SEVERITY_ERROR,      TRUE);
			ID3D11InfoQueue_SetBreakOnSeverity(rx.d3d11.inf, D3D11_MESSAGE_SEVERITY_WARNING,    TRUE);
		}
	}
#endif
	rx_assert(SUCCEEDED(error));

	wchar_t unicode_window_title[MAX_PATH];
	MultiByteToWideChar(CP_ACP,0,window_title,-1,unicode_window_title,MAX_PATH);

	WNDCLASSW wnd_class;
	ZeroMemory(&wnd_class,sizeof(wnd_class));
	wnd_class.lpfnWndProc=rx_window_message_callback_win32;
	wnd_class.hInstance=GetModuleHandleW(NULL);
	wnd_class.lpszClassName=unicode_window_title;
	if (RegisterClassW(&wnd_class)) {
		int wnd_size_x = window_width  != 0 ? window_width  : _RX_DEFAULT_WINDOW_SIZE_X;
		int wnd_size_y = window_height != 0 ? window_height : _RX_DEFAULT_WINDOW_SIZE_Y;
		if(wnd_size_x == CW_USEDEFAULT) {
			wnd_size_x = 720;
		}
		if(wnd_size_y == CW_USEDEFAULT) {
			wnd_size_y = 720;
		}
		RECT wnd_rect;
		wnd_rect.  left=0;
		wnd_rect.   top=0;
		wnd_rect. right=wnd_size_x;
		wnd_rect.bottom=wnd_size_y;
		AdjustWindowRect(&wnd_rect,WS_OVERLAPPEDWINDOW,FALSE);

		wnd_size_x = wnd_rect. right - wnd_rect.left;
		wnd_size_y = wnd_rect.bottom - wnd_rect. top;

		/* This makes the window not resizable */
		// &~WS_THICKFRAME
		rx.wnd.win32.handle = CreateWindowExW(WS_EX_NOREDIRECTIONBITMAP,wnd_class.lpszClassName,unicode_window_title,
		WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,wnd_size_x,wnd_size_y,
		NULL,NULL,wnd_class.hInstance,NULL);
	}

	/* [[!]]:
		Poll here to get the window dimensions, which are needed to create some
		window dependent resources */
	rxpoll();

	IDXGIDevice * device_dxgi = NULL;
	IDXGIAdapter * adapter_dxgi = NULL;
	IDXGIFactory2 * factory_dxgi = NULL;

	ID3D11Device_QueryInterface(rx.d3d11.dev,&IID_IDXGIDevice,(void **)&device_dxgi);
	IDXGIDevice_GetAdapter(device_dxgi,&adapter_dxgi);
	IDXGIAdapter_GetParent(adapter_dxgi,&IID_IDXGIFactory2,(void**)&factory_dxgi);

	// DXGI_USAGE_UNORDERED_ACCESS
	DXGI_SWAP_CHAIN_DESC1 sc_config_d3d;
	ZeroMemory(&sc_config_d3d,sizeof(sc_config_d3d));
	sc_config_d3d.Width=rx.wnd.size_x;
	sc_config_d3d.Height=rx.wnd.size_y;
	sc_config_d3d.Format=DXGI_FORMAT_R8G8B8A8_UNORM;
	sc_config_d3d.BufferUsage=DXGI_USAGE_RENDER_TARGET_OUTPUT;
	sc_config_d3d.BufferCount=2;
	sc_config_d3d.SwapEffect=DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
	// ResizeBuffers conflicts with this flag :(
	// |DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
	sc_config_d3d.Flags=DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
	/* todo: allow the user to specify this */
	sc_config_d3d.SampleDesc.  Count=1;
	sc_config_d3d.SampleDesc.Quality=0;

	DXGI_SWAP_CHAIN_FULLSCREEN_DESC sc_fs_config;
	ZeroMemory(&sc_fs_config,sizeof(sc_fs_config));
	sc_fs_config.RefreshRate.Numerator=_RX_REFRESH_RATE;
	sc_fs_config.RefreshRate.Denominator=1;
	sc_fs_config.Windowed=TRUE;

	error = IDXGIFactory2_CreateSwapChainForHwnd(factory_dxgi,(IUnknown *)rx.d3d11.dev,rx.wnd.win32.handle,&sc_config_d3d,&sc_fs_config,NULL,(IDXGISwapChain1 **)&rx.wnd.out.d3d11.swap_chain);
	rx_assert(SUCCEEDED(error));

	ID3D11Texture2D *texture_d3d;
	error = IDXGISwapChain_GetBuffer(rx.wnd.out.d3d11.swap_chain,0,&IID_ID3D11Texture2D,(void **)&texture_d3d);
	rx_assert(SUCCEEDED(error));
	// rxGPU_delete_texture(rx.imp.pip.out.color[0]);
	// rxGPU_delete_texture(rx.imp.pip.out.depth);
	// rxGPU_delete_texture(rx.wnd.out.tar);
	// __debugbreak();
	// ID3D11DeviceContext_ClearState(rx.d3d11.ctx);
	// error = IDXGISwapChain_ResizeBuffers(rx.wnd.out.d3d11.swap_chain,sc_config_d3d.BufferCount,512,512,sc_config_d3d.Format,0);


	// rx.wnd.out.d3d11.frame_await = IDXGISwapChain2_GetFrameLatencyWaitableObject(rx.wnd.out.d3d11.swap_chain);

	rxGPU_TEXTURE config;
	ZeroMemory(&config,sizeof(config));
	config.memtype = D3D11_USAGE_DEFAULT;
	config.useflag = D3D11_BIND_RENDER_TARGET;
	config.size_x = sc_config_d3d. Width;
	config.size_y = sc_config_d3d.Height;
	config.format = sc_config_d3d.Format;
	config.d3d11.texture_2d = texture_d3d;

	rx.wnd.out.tar = rxGPU_create_texture_ex(&config);

	IDXGIFactory_Release(factory_dxgi);
	IDXGIAdapter_Release(adapter_dxgi);
	IDXGIDevice_Release(device_dxgi);

	rxIMP_init();

	rxGPU_set_clip(0,0,rx.wnd.size_x,rx.wnd.size_y);

	D3D11_VIEWPORT viewport_d3d;
	viewport_d3d.TopLeftX=0;
	viewport_d3d.TopLeftY=0;
	viewport_d3d.   Width=rx.wnd.size_x;
	viewport_d3d.  Height=rx.wnd.size_y;
	viewport_d3d.MinDepth=0;
	viewport_d3d.MaxDepth=1;
	ID3D11DeviceContext_RSSetViewports(rx.d3d11.ctx,1,&viewport_d3d);

	rx.start_ticks=rx_getClockTicks();
	rx.frame_ticks=rx.start_ticks;

	rxpoll();
}

LRESULT CALLBACK
rx_window_message_callback_win32(HWND Window,UINT Message,WPARAM wParam,LPARAM lParam) {
	LRESULT result = rx_window_message_handler_win32(Message,wParam,lParam);
	if(result != TRUE) {
		result = DefWindowProcW(Window,Message,wParam,lParam);
	}
	return result;
}

int
rx_window_message_handler_win32(UINT Message, WPARAM wParam, LPARAM lParam) {
	switch(Message) {
		case WM_CLOSE:
		case WM_QUIT: {
			PostQuitMessage(0);
			rx.wnd.off = TRUE;
		} break;
		case WM_SIZE: {
			RECT client;
			if (GetClientRect(rx.wnd.win32.handle,&client)) {
				int size_x = client. right - client.left;
				int size_y = client.bottom - client. top;

				if (rx.wnd.size_x != size_x || rx.wnd.size_y != size_y) {
					rx.wnd.size_x = size_x;
					rx.wnd.size_y = size_y;
					rx.wnd.center_x=size_x>>1;
					rx.wnd.center_y=size_y>>1;

					D3D11_VIEWPORT viewport_d3d;
					viewport_d3d.TopLeftX=0;
					viewport_d3d.TopLeftY=0;
					viewport_d3d.   Width=size_x;
					viewport_d3d.  Height=size_y;
					viewport_d3d.MinDepth=0;
					viewport_d3d.MaxDepth=1;
					ID3D11DeviceContext_RSSetViewports(rx.d3d11.ctx,1,&viewport_d3d);

					// rxGPU_delete_texture(rx.imp.pip.out.color[0]);
					// rxGPU_delete_texture(rx.imp.pip.out.depth);
					// rxGPU_delete_texture(rx.wnd.out.tar);
					// HRESULT error = IDXGISwapChain_ResizeBuffers(rx.wnd.out.d3d11.swap_chain,0,size_x,size_y,DXGI_FORMAT_UNKNOWN,0);
					// if SUCCEEDED(error) {
					// 	// __debugbreak();
					// } else {
					// 	__debugbreak();
					// }
					rxGPU_set_clip(0,0,size_x,size_y);
				}

				/* [[TODO]] */
				// rx.imp.pip.out.count = 1;
				// rx.imp.pip.out.color[0] = rxGPU_create_color_target(rx.wnd.out.tar->size_x,rx.wnd.out.tar->size_y,rx.wnd.out.tar->format,_RX_MSAA,0);
				// rx.imp.pip.out.depth    = rxGPU_create_depth_target(rx.wnd.out.tar->size_x,rx.wnd.out.tar->size_y,DXGI_FORMAT_D32_FLOAT);




				#if 0
				rxGPU_TEXTURE config;
				ZeroMemory(&config,sizeof(config));
				config.memtype = D3D11_USAGE_DEFAULT;
				config.useflag = D3D11_BIND_RENDER_TARGET;
				config.size_x = sc_config_d3d. Width;
				config.size_y = sc_config_d3d.Height;
				config.format = sc_config_d3d.Format;
				config.d3d11.texture_2d = texture_d3d;

				rx.wnd.out.tar = rxGPU_create_texture_ex(&config);
				#endif
			}
		} break;
		case WM_MOUSEMOVE: {
			int xcursor=GET_X_LPARAM(lParam);
			int ycursor=GET_Y_LPARAM(lParam);
			rx.wnd.in.mice.xcursor=xcursor;
			rx.wnd.in.mice.ycursor=rx.wnd.size_y-ycursor;
		} break;
		case WM_MOUSEWHEEL: {
			rx.wnd.in.mice.yscroll = GET_WHEEL_DELTA_WPARAM(wParam)/WHEEL_DELTA;
		} break;
// SetCapture((HWND)rx.wnd.win32.handle);
		case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK: case WM_LBUTTONUP: {
			rx.wnd.in.mice.btn_cur |= (Message!=WM_LBUTTONUP) << 0;
		} break;
		case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK: case WM_RBUTTONUP: {
			rx.wnd.in.mice.btn_cur |= (Message!=WM_RBUTTONUP) << 1;
		} break;
// ReleaseCapture();
		case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK: case WM_MBUTTONUP: {
			rx.wnd.in.mice.btn_cur |= (Message!=WM_MBUTTONUP) << 2;
		} break;
		case WM_CHAR: {
			rx.wnd.in.kbrd.chr = wParam;
		} break;
		case WM_SYSKEYUP: case WM_SYSKEYDOWN: case WM_KEYUP: case WM_KEYDOWN: {
			/* todo: there's probably a better way to do this */
			rx.wnd.in.kbrd.is_shft = (GetKeyState(VK_SHIFT)   & 0x8000) != 0;
			rx.wnd.in.kbrd.is_ctrl = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
			rx.wnd.in.kbrd.is_menu = (GetKeyState(VK_MENU)    & 0x8000) != 0;

			int key_map = 0;
			if isWithin3(wParam,'a','z','A','Z','0','9') {
				key_map = wParam;
			}

			switch(wParam) {
				case VK_CONTROL:    key_map = rx_kLCTRL;     break;
				case VK_RETURN:     key_map = rxKEY_kRETURN;    break;
				case VK_BACK:       key_map = rx_kBCKSPC;    break;
				case VK_DELETE:     key_map = rx_kDELETE;    break;
				case VK_HOME:       key_map = rx_kHOME;      break;
				case VK_END:        key_map = rx_kEND;       break;
				case VK_ESCAPE:     key_map = rx_kESCAPE;    break;

				case VK_LEFT:       key_map = rxKEY_kLEFT;  break;
				case VK_RIGHT:      key_map = rxKEY_kRIGHT; break;
				case VK_UP:         key_map = rxKEY_kUP;    break;
				case VK_DOWN:       key_map = rxKEY_kDOWN;  break;

				case VK_F1:  key_map = rxKEY_kF1;  break;
				case VK_F2:  key_map = rxKEY_kF2;  break;
				case VK_F3:  key_map = rxKEY_kF3;  break;
				case VK_F4:  key_map = rxKEY_kF4;  break;
				case VK_F5:  key_map = rxKEY_kF5;  break;
				case VK_F6:  key_map = rxKEY_kF6;  break;
				case VK_F7:  key_map = rxKEY_kF7;  break;
				case VK_F8:  key_map = rxKEY_kF8;  break;
				case VK_F9:  key_map = rxKEY_kF9;  break;
				case VK_F10: key_map = rxKEY_kF10; break;
				case VK_F11: key_map = rxKEY_kF11; break;
				case VK_F12: key_map = rxKEY_kF12; break;
				/* waste of time */
				case VK_SPACE:      key_map =  ' '; break;
				case VK_OEM_PLUS:   key_map =  '='; break;
				case VK_OEM_PERIOD: key_map =  '.'; break;
				case VK_OEM_COMMA:  key_map =  ','; break;
				case VK_OEM_1:      key_map =  ';'; break;
				case VK_OEM_2:      key_map =  '/'; break;
				case VK_OEM_3:      key_map =  '~'; break;
				case VK_OEM_4:      key_map =  '['; break;
				case VK_OEM_5:      key_map = '\\'; break;
				case VK_OEM_6:      key_map =  ']'; break;
				case VK_OEM_7:      key_map = '\''; break;
			}

			rx.wnd.in.kbrd.key[key_map] = (Message == WM_KEYDOWN) || (Message == WM_SYSKEYDOWN);
		} break;
		default: {
			return FALSE;
		}
	}
	return TRUE;
}

#pragma warning(pop)
#endif

